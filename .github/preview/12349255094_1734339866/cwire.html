
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cwire: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/prebid/prebid-server/v3/adapters/cwire/cwire.go (95.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cwire

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/prebid/openrtb/v20/openrtb2"
        "github.com/prebid/prebid-server/v3/adapters"
        "github.com/prebid/prebid-server/v3/config"
        "github.com/prebid/prebid-server/v3/errortypes"
        "github.com/prebid/prebid-server/v3/openrtb_ext"
        "github.com/prebid/prebid-server/v3/util/jsonutil"
)

/*
Bid adapter implements and exports the requirements:

- The adapters.Builder method to create a new instance of the adapter based on
  the host configuration

- The adapters.Bidder interface consisting of the MakeRequests method to create
  outgoing requests to your bidding server and the MakeBids method to create bid
  responses.
*/

type adapter struct {
        endpoint string
}

// Builder builds a new instance of the CWire adapter for the given bidder with the given config.
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov8" title="1">{
        bidder := &amp;adapter{
                endpoint: config.Endpoint,
        }
        return bidder, nil
}</span>

/*
This method creates an HTTP requests that should be sent to the CWire OpenRTB endpoint.
It's only provided with valid impressions for the adapter, it's not called if there is none.
For optimization purposes bid adapters are forbidden from directly initiating any form of
network communication and must entirely rely upon the core framework (adapters.RequestData).
*/
func (a *adapter) MakeRequests(request *openrtb2.BidRequest, reqInfo *adapters.ExtraRequestInfo) ([]*adapters.RequestData, []error) <span class="cov8" title="1">{
        headers := http.Header{}
        headers.Add("Content-Type", "application/json;charset=utf-8")
        headers.Add("Accept", "application/json")

        resJSON, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{fmt.Errorf("Error while encoding OpenRTB BidRequest: %v", err)}
        }</span>

        <span class="cov8" title="1">reqs := []*adapters.RequestData{
                {
                        Method:  "POST",
                        Uri:     a.endpoint,
                        Body:    resJSON,
                        Headers: headers,
                        ImpIDs:  openrtb_ext.GetImpIDs(request.Imp),
                },
        }

        return reqs, nil</span>
}

/*
This method is called for every Bid Response from CWire's OpenRTB endpoint.
It maps the responses to core framework's OpenRTB 2.5 Bid Response object model.
*/
func (a *adapter) MakeBids(bidReq *openrtb2.BidRequest, unused *adapters.RequestData, httpRes *adapters.ResponseData) (*adapters.BidderResponse, []error) <span class="cov8" title="1">{
        if httpRes.StatusCode == http.StatusNoContent </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if httpRes.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, []error{
                        fmt.Errorf("Unexpected status code: %d. Run with request.debug = 1 for more info", httpRes.StatusCode),
                }
        }</span>

        <span class="cov8" title="1">var resp openrtb2.BidResponse
        if err := jsonutil.Unmarshal(httpRes.Body, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: fmt.Sprintf("Error while decoding response, err: %s", err),
                }}
        }</span>

        <span class="cov8" title="1">bidderResponse := adapters.NewBidderResponse()
        bidderResponse.Currency = resp.Cur
        for _, sb := range resp.SeatBid </span><span class="cov8" title="1">{
                for i := range sb.Bid </span><span class="cov8" title="1">{
                        bidderResponse.Bids = append(bidderResponse.Bids, &amp;adapters.TypedBid{
                                Bid:     &amp;sb.Bid[i],
                                BidType: openrtb_ext.BidTypeBanner,
                        })
                }</span>
        }

        <span class="cov8" title="1">return bidderResponse, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
